const axios = require('./node_modules/axios');
const upndown = require('./node_modules/upndown/lib/upndown.node');
const $ = require('cheerio');
const fs = require('fs');
const testSchema = require('./schema/test-schema');
const macroSchema = require('./schema/macro-schema');
const und = new upndown();

const convertToMarkdown = html => {
  return new Promise((resolve, reject) => {
    und.convert(html, (err, markdown) => {
      if (err) {
        return reject(err);
      }

      return resolve(markdown);
    });
  })
}

const docs = [
  {
    url: 'https://getopentest.org/reference/selenium-keywords.html',
    namespace: 'org.getopentest.selenium',
    type: "action",
    sectionSelector: '.sect2',
    getActionName: (context) => $('h3', context).text(),
    getActionDescription: (context) => {
      return convertToMarkdown($('h3', context).next().html())
    },
    argumentTableSelector: 'table'
  },
  {
    url: 'https://getopentest.org/reference/appium-keywords.html',
    namespace: 'org.getopentest.appium',
    type: "action",
    sectionSelector: '.sect2',
    getActionName: (context) => $('h3', context).text(),
    getActionDescription: (context) => {
      return convertToMarkdown($('h3', context).next().html())
    },
    argumentTableSelector: 'table',
    swipeSelector: 'h2#swipe-related-keyword-arguments',
    swipeArgumentPlaceHolder: 'swipe +',
    getSwipeArguments: (context) => {
      const section = $('h2#swipe-related-keyword-arguments', context).next();
      return parseArgumentTable('table', section);
    }
  },
  {
    url: 'https://getopentest.org/reference/generic-keywords.html',
    type: "action",
    sectionSelector: '.sect2',
    getActionName: (context) => $('p:contains("Full name:") code', context).text(),
    getActionDescription: (context) => {
      return convertToMarkdown($('p:contains("Full name:")', context).parent().next().html())
    },
    argumentTableSelector: 'table'
  },
  // {
  //   url: 'https://getopentest.org/reference/javascript-api.html',
  //   type: "variable"
  // }
];

const parseArgumentTable = (tableSelector, section) => {
  const $argumentElements = $(tableSelector, section).first().find('tr');
  const arguments = [];
  $argumentElements.map((_, $argumentElement) => {
    const [$argumentNameElement, $argumentDescriptionElement] = $('td', $argumentElement).toArray();

    const argumentName = $($argumentNameElement).text();
    const isRequired = $($argumentNameElement).has('strong').length > 0;
    const argumentDescription = $($argumentDescriptionElement).text();
    const availableValues = $($argumentDescriptionElement).find('li code').toArray().map(availableValue => $(availableValue).text())
    const isEnum = availableValues.length > 0;

    arguments.push({
      argumentName,
      isRequired,
      argumentDescription,
      availableValues,
      isEnum
    })
  })

  return arguments;
}

async function asyncForEach(array, callback) {
  for (let index = 0; index < array.length; index++) {
    await callback(array[index], index, array);
  }
}

const generateJsonSchema = async () => {
  const documentPromises = docs.map(doc => axios.get(doc.url).then(res => res.data));
  const documents = await Promise.all(documentPromises).then(t => t.map((documentHTML, index) => ({
    setting: docs[index],
    html: documentHTML
  })));

  const actions = [];

  await asyncForEach(documents, async document => {
    const $sections = $(document.setting.sectionSelector, document.html);

    let swipeArguments = [];

    if (document.setting.swipeArgumentPlaceHolder) {
      swipeArguments = document.setting.getSwipeArguments(document.html);
    }

    await asyncForEach($sections, async ($section) => {
      const actionName = document.setting.getActionName($section);
      const actionDescription = await document.setting.getActionDescription($section);
      
      if (actionName) {
        const actionWithNameSpace = document.setting.namespace ? `${document.setting.namespace}.${actionName}` : actionName;

        let arguments = parseArgumentTable(document.setting.argumentTableSelector, $section);


        const hasPlaceHolder = arguments.find(agrs => agrs.argumentName === document.setting.swipeArgumentPlaceHolder);

        if (hasPlaceHolder) {
          arguments = arguments.filter(agrs => agrs.argumentName !== document.setting.swipeArgumentPlaceHolder).concat(swipeArguments);
        }

        actions.push({
          actionWithNameSpace,
          actionDescription,
          arguments
        });

      }
    })
  });

  return actions;
}

generateJsonSchema()
  .then(actions => {
    console.log(actions.length)
    const actionNames = actions.map(action => action.actionWithNameSpace);
    const actionDescriptions = actions.map(action => action.actionDescription);
    testSchema.definitions.action.properties.action.enum = actionNames;
    macroSchema.definitions.action.properties.action.enum = actionNames;
    testSchema.definitions.action.properties.action.enumDescriptions = actionDescriptions;
    macroSchema.definitions.action.properties.action.enumDescriptions = actionDescriptions;

    const allOfDefinition = actions.map(action => {
      const argumentProperties = action.arguments.reduce((result, arg) => {
        const argProperty = {
          type: ['string', 'number', 'object', 'array', 'boolean'],
          description: arg.argumentDescription
        };

        if (arg.isEnum) {
          argProperty.enum = arg.availableValues;
        }

        result[arg.argumentName] = argProperty;

        return result;
      }, {});

      const requiredArguments = action.arguments.filter(arg => arg.isRequired).map(arg => arg.argumentName);

      return {
        "if": {
          "properties": {
            "action": {
              "const": action.actionWithNameSpace
            }
          }
        },
        "then": {
          "properties": {
            "args": {
              "type": "object",
              "properties": argumentProperties,
              "required": requiredArguments
            }
          },
          "title": action.actionDescription,
          "required": requiredArguments.length > 0 ? ['args'] : []
        }
      }
    });

    testSchema.definitions.action.allOf = allOfDefinition;
    macroSchema.definitions.action.allOf = allOfDefinition;

    fs.writeFileSync('out/test.schema.json', JSON.stringify(testSchema, null, 2))
    fs.writeFileSync('out/macro.schema.json', JSON.stringify(macroSchema, null, 2))
  })
  .catch(err => console.log(err));